{"ast":null,"code":"// bellmanFord.js\nexport function bellmanFord(grid, startNode, finishNode) {\n  const nodes = getAllNodes(grid);\n  startNode.distance = 0;\n  for (let i = 1; i < nodes.length; i++) {\n    for (const node of nodes) {\n      if (node.distance === Infinity) continue;\n      const neighbors = getUnvisitedNeighbors(node, grid);\n      for (const neighbor of neighbors) {\n        const newDist = node.distance + 1;\n        if (newDist < neighbor.distance) {\n          neighbor.distance = newDist;\n          neighbor.previousNode = node;\n        }\n      }\n    }\n  }\n  for (const node of nodes) {\n    if (node.distance === Infinity) continue;\n    const neighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of neighbors) {\n      const newDist = node.distance + 1;\n      if (newDist < neighbor.distance) {\n        return []; // Negative weight cycle detected\n      }\n    }\n  }\n  const visitedNodesInOrder = [];\n  for (const node of nodes) {\n    if (node.distance !== Infinity) {\n      visitedNodesInOrder.push(node);\n    }\n  }\n  return visitedNodesInOrder;\n}\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {\n    row,\n    col\n  } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isWall);\n}","map":{"version":3,"names":["bellmanFord","grid","startNode","finishNode","nodes","getAllNodes","distance","i","length","node","Infinity","neighbors","getUnvisitedNeighbors","neighbor","newDist","previousNode","visitedNodesInOrder","push","row","col","filter","isWall"],"sources":["/Users/mac/Desktop/path_find 2/src/algorithms/bellmanford.js"],"sourcesContent":["// bellmanFord.js\nexport function bellmanFord(grid, startNode, finishNode) {\n    const nodes = getAllNodes(grid);\n    startNode.distance = 0;\n  \n    for (let i = 1; i < nodes.length; i++) {\n      for (const node of nodes) {\n        if (node.distance === Infinity) continue;\n  \n        const neighbors = getUnvisitedNeighbors(node, grid);\n        for (const neighbor of neighbors) {\n          const newDist = node.distance + 1;\n          if (newDist < neighbor.distance) {\n            neighbor.distance = newDist;\n            neighbor.previousNode = node;\n          }\n        }\n      }\n    }\n  \n    for (const node of nodes) {\n      if (node.distance === Infinity) continue;\n  \n      const neighbors = getUnvisitedNeighbors(node, grid);\n      for (const neighbor of neighbors) {\n        const newDist = node.distance + 1;\n        if (newDist < neighbor.distance) {\n          return []; // Negative weight cycle detected\n        }\n      }\n    }\n  \n    const visitedNodesInOrder = [];\n    for (const node of nodes) {\n      if (node.distance !== Infinity) {\n        visitedNodesInOrder.push(node);\n      }\n    }\n  \n    return visitedNodesInOrder;\n  }\n  \n  function getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n  }\n  \n  function getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {row, col} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isWall);\n  }\n  "],"mappings":"AAAA;AACA,OAAO,SAASA,WAAWA,CAACC,IAAI,EAAEC,SAAS,EAAEC,UAAU,EAAE;EACrD,MAAMC,KAAK,GAAGC,WAAW,CAACJ,IAAI,CAAC;EAC/BC,SAAS,CAACI,QAAQ,GAAG,CAAC;EAEtB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;IACrC,KAAK,MAAME,IAAI,IAAIL,KAAK,EAAE;MACxB,IAAIK,IAAI,CAACH,QAAQ,KAAKI,QAAQ,EAAE;MAEhC,MAAMC,SAAS,GAAGC,qBAAqB,CAACH,IAAI,EAAER,IAAI,CAAC;MACnD,KAAK,MAAMY,QAAQ,IAAIF,SAAS,EAAE;QAChC,MAAMG,OAAO,GAAGL,IAAI,CAACH,QAAQ,GAAG,CAAC;QACjC,IAAIQ,OAAO,GAAGD,QAAQ,CAACP,QAAQ,EAAE;UAC/BO,QAAQ,CAACP,QAAQ,GAAGQ,OAAO;UAC3BD,QAAQ,CAACE,YAAY,GAAGN,IAAI;QAC9B;MACF;IACF;EACF;EAEA,KAAK,MAAMA,IAAI,IAAIL,KAAK,EAAE;IACxB,IAAIK,IAAI,CAACH,QAAQ,KAAKI,QAAQ,EAAE;IAEhC,MAAMC,SAAS,GAAGC,qBAAqB,CAACH,IAAI,EAAER,IAAI,CAAC;IACnD,KAAK,MAAMY,QAAQ,IAAIF,SAAS,EAAE;MAChC,MAAMG,OAAO,GAAGL,IAAI,CAACH,QAAQ,GAAG,CAAC;MACjC,IAAIQ,OAAO,GAAGD,QAAQ,CAACP,QAAQ,EAAE;QAC/B,OAAO,EAAE,CAAC,CAAC;MACb;IACF;EACF;EAEA,MAAMU,mBAAmB,GAAG,EAAE;EAC9B,KAAK,MAAMP,IAAI,IAAIL,KAAK,EAAE;IACxB,IAAIK,IAAI,CAACH,QAAQ,KAAKI,QAAQ,EAAE;MAC9BM,mBAAmB,CAACC,IAAI,CAACR,IAAI,CAAC;IAChC;EACF;EAEA,OAAOO,mBAAmB;AAC5B;AAEA,SAASX,WAAWA,CAACJ,IAAI,EAAE;EACzB,MAAMG,KAAK,GAAG,EAAE;EAChB,KAAK,MAAMc,GAAG,IAAIjB,IAAI,EAAE;IACtB,KAAK,MAAMQ,IAAI,IAAIS,GAAG,EAAE;MACtBd,KAAK,CAACa,IAAI,CAACR,IAAI,CAAC;IAClB;EACF;EACA,OAAOL,KAAK;AACd;AAEA,SAASQ,qBAAqBA,CAACH,IAAI,EAAER,IAAI,EAAE;EACzC,MAAMU,SAAS,GAAG,EAAE;EACpB,MAAM;IAACO,GAAG;IAAEC;EAAG,CAAC,GAAGV,IAAI;EACvB,IAAIS,GAAG,GAAG,CAAC,EAAEP,SAAS,CAACM,IAAI,CAAChB,IAAI,CAACiB,GAAG,GAAG,CAAC,CAAC,CAACC,GAAG,CAAC,CAAC;EAC/C,IAAID,GAAG,GAAGjB,IAAI,CAACO,MAAM,GAAG,CAAC,EAAEG,SAAS,CAACM,IAAI,CAAChB,IAAI,CAACiB,GAAG,GAAG,CAAC,CAAC,CAACC,GAAG,CAAC,CAAC;EAC7D,IAAIA,GAAG,GAAG,CAAC,EAAER,SAAS,CAACM,IAAI,CAAChB,IAAI,CAACiB,GAAG,CAAC,CAACC,GAAG,GAAG,CAAC,CAAC,CAAC;EAC/C,IAAIA,GAAG,GAAGlB,IAAI,CAAC,CAAC,CAAC,CAACO,MAAM,GAAG,CAAC,EAAEG,SAAS,CAACM,IAAI,CAAChB,IAAI,CAACiB,GAAG,CAAC,CAACC,GAAG,GAAG,CAAC,CAAC,CAAC;EAChE,OAAOR,SAAS,CAACS,MAAM,CAACP,QAAQ,IAAI,CAACA,QAAQ,CAACQ,MAAM,CAAC;AACvD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}